// // 문제 M : 블랙홀

// 문제 설명
// 블랙홀은 가까이 가면 갈수록 중력이 강해서 빨려들어가기 쉽다.
// 블랙홀 중앙점인 중력 특이점으로 향할수록 커지는 중력 값을 표현하라.
// 행렬의 크기 N를 입력받아 중력 특이점이 N으로 시작하는
// N * N행렬을 출력하시오.
// 입력 설명

// N
// N(정수): 행렬의 행, 열 크기

// 0 <= N < 101

// 출력 설명
// N * N 행렬을 띄어쓰기와 줄바꿈으로 구분하여 출력한다.
// 입력 예시
// 5
// 출력 예시
// 3 3 3 3 3
// 3 4 4 4 3
// 3 4 5 4 3
// 3 4 4 4 3
// 3 3 3 3 3

// ACCEPTED CODE

#include <stdio.h>

int main()
{

    int N;
    scanf("%d", &N);
    int matrix[N][N];

    // 홀수와 짝수는 핵의 크기가 1이냐 2x2이냐로 다르므로 나눠보자
    // 3 -> 2겹, 5 -> 3겹, 7 -> 4겹, ... -> (n + 1)/2
    // 4 -> 2겹, 6 -> 3겹, 8 -> 4겹, ... -> n / 2
    // 하지만 짝수 2k가 있다면 (2k+1)/2 = k + 1/2 -> k(나눗셈 연산은 몫만 취급)

    // Level Test에서 맨 끝의 테두리만 0으로 만드는 문제에서 아이디어 차용
    // 중앙은 N을 넣고, 직후 테두리는 (N-1), 다음은 (N-2), ...
    // 만약 N=5일 때는 껍데기가 3개이므로 (n + 1) / 2번 시행하면 될거 같다.

    int layer = (N + 1) / 2;
    for (int i = 0; i < layer; i++)
    {
        int num = N - layer + i + 1;
        for (int j = i; j < N - i; j++)
        {
            // 상, 하, 좌, 우
            matrix[i][j] = num;
            matrix[N - i - 1][j] = num;
            matrix[j][i] = num;
            matrix[j][N - i - 1] = num;
        }
    }

    for (int i = 0; i < N; i++)
    {
        for (int j = 0; j < N; j++)
        {
            printf("%d ", matrix[i][j]);
        }
        printf("\n");
    }

    return 0;
}